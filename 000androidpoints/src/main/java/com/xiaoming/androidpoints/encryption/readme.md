MD5,SHA;
AES,DES;
RSA;
Base64;
UTF-8,UTF-16;

1 各种算法
数据加密，是一门历史悠久的技术，指通过 加密算法和加密密钥将明文转变为密文，而解密则是通过解密算法和解密密钥将密文恢复为明文。
它的核心是密码学。数据加密目前仍是 计算机系统对信息进行保护的一种最可靠的办法。它利用密码技术对信息进行加密，实现信息隐蔽，
从而起到保护信息的安全的作用。
(1)MD5  摘要算法
1)md5是一种信息摘要算法,还有另外一种叫法：指纹。
它可以从一个字符串或一个文件中按照一定的规则生成一个特殊的字符串（这个特殊的字符串就被称之为摘要，
我理解就是从文件中摘一些信息片段加工而来），并且一个文件所对应的MD5摘要是固定的，当文件内容变化后，其MD5值也会不一样
（虽然理论上来说也有可能会一样，但概率极小），因此，在应用中经常使用MD5值来验证一段数据有没有被篡改。
比如，在数据的发送方将原始数据生成出MD5值，然后把原始数据连同其MD5值一起传给接收方，接收该收到数据后，
先将原始数据用MD5算法生成摘要信息，然后再将此摘要信息与发送方发过来的摘要信息进行比较，如果一致就认为原始数据没有被修改，
否则原始数据就是被修改过了。
常见的摘要算法包括：md、sha这两类。md包括md2、md4、md5；sha包括sha1、sha224、sha256、sha384、sha512。
2)java中实现md5加密，有三种方式
https://www.cnblogs.com/-beyond/p/10575078.html
使用jdk内置的方法实现实现md5加密
使用bc方式实现md5加密
使用Cc方式实现md5加密

(2) AES 对称加密
AES加密算法的详细介绍与实现: https://blog.csdn.net/qq_28205153/article/details/55798628
1)高级加密标准（Advanced Encryption Standard，AES）
高级加密标准(AES,Advanced Encryption Standard)为最常见的对称加密算法(微信小程序加密传输就是用这个加密算法的)。对称加密算法也就是加密和解密用相同的密钥
AES是一个对称分组密码算法
AES最常见的有3种方案，用以适应不同的场景要求，分别是AES-128、AES-192和AES-256。
2) 各个部分的作用与意义
密钥K:
用来加密明文的密码，在对称加密算法中，加密与解密的密钥是相同的。密钥为接收方与发送方协商产生，但不可以直接在网络上传输，
否则会导致密钥泄漏，通常是通过非对称加密算法加密密钥，然后再通过网络传输给对方，或者直接面对面商量密钥。密钥是绝对不可以泄漏的，否则会被攻击者还原密文，窃取机密数据。
AES加密函数:
设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。设AES加密函数为E，则 C = E(K, P),其中P为明文，K为密钥，C为密文。也就是说，把明文P和密钥K作为加密函数的参数输入，则加密函数E会输出密文C。
AES解密函数:
设AES解密函数为D，则 P = D(K, C),其中C为密文，K为密钥，P为明文。也就是说，把密文C和密钥K作为解密函数的参数输入，则解密函数会输出明文P。
实际中，一般是通过RSA加密AES的密钥，传输到接收方，接收方解密得到AES密钥，然后发送方和接收方用AES密钥来通信。
3)AES的基本结构
AES为分组密码，分组密码也就是把明文分成一组一组的，每组长度相等，每次加密一组数据，直到加密完整个明文。在AES标准规范中，分组长度只能是128位，也就是说，每个分组为16个字节（每个字节8位）。密钥的长度可以使用128位、192位或256位。密钥的长度不同，推荐加密轮数也不同

(3) SHA 摘要算法
1)sha类加密算法有多种，共两大类，一类是sha1，另一类包含多种加密算法：sha224、sha256、sha384、sha512，这些统称为sha2。
其中sha1加密后的长度是160byte，sha2加密之后的密文长度和shaXxx的数字相同，比如sha256加密之后，密文长度为256byte。
2)java中实现sha1加密，有三种方式
https://www.cnblogs.com/-beyond/p/10575078.html
使用jdk内置的方法实现实现md5加密
使用bc方式实现md5加密
使用Cc方式实现md5加密

(4) DES 对称加密
1)des对称加密，是一种比较传统的加密方式，其加密运算、解密运算使用的是同样的密钥，信息的发送者和信息的接收者在进行信息的传输与处理时，必须共同持有该密码（称为对称密码）
DES采用了64位的分组长度和56位的密钥长度
2)要求秘钥必须是8个字节，即64bit长度 因为秘钥是byte[8]，代表字符串也可以是非可见的字节，可以与Base64编码算法一起使用 加密、解密都需要通过字节数组作为数据和密钥进行处理

(5)Base64
1)是什么
Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。
Base64编码是从二进制到字符的过程，可用于在HTTP环境下传递较长的标识信息。采用Base64编码具有不可读性，需要解码后才能阅读。
2)为什么用
Base64编码是从二进制值到某些特定字符的编码，这些特定字符一共64个，所以称作Base64。
为什么不直接传输二进制呢？比如图片，或者字符，既然实际传输时它们都是二进制字节流。而且即使Base64编码过的字符串最终也是二进制（通常是UTF-8编码，兼容ASCII编码）在网络上传输的，那么用4/3倍带宽传输数据的Base64究竟有什么意义？
真正的原因是二进制不兼容。某些二进制值，在一些硬件上，比如在不同的路由器，老电脑上，表示的意义不一样，做的处理也不一样。同样，一些老的软件，网络协议也有类似的问题。
但是万幸，Base64使用的64个字符，经ASCII/UTF-8编码后在大多数机器，软件上的行为是一样的。

用记事本打开exe、jpg、pdf这些文件时，我们都会看到一大堆乱码，因为二进制文件包含很多无法显示和打印的字符，所以，如果要让记事本这样的文本处理软件能处理二进制数据，就需要一个二进制到字符串的转换方法。Base64是一种最常见的二进制编码方法。
有些情况下传输不可见字符不方便。比如一个纯文本协议，二进制中可能会出现被当做控制字符处理的部分。这样引起传输失败。
3)应用场景
Base64编码可用于在HTTP环境下传递较长的标识信息。
一个xml当中包含另一个xml数据，此时如果将xml数据直接写入显然不合适，将xml进行适当编码存入较为方便，事实上xml当中的字符一般都是可见字符（0-127之间），但是由于中文的存在，可能存在不可见字符，直接将字符打印在外层xml的数据中显然不合理，那么怎么办呢？
可以使用base64进行编码，然后存入xml，解码反之
其实还有个办法，将byte的值写在xml当中，空格或者，分开，这样也可以将byte数据传入，不过这样更浪费空间，并且不易保存.
4)java中使用
import java.util.Base64;
  对于标准的Base64：
  加密为字符串使用Base64.getEncoder().encodeToString();
  加密为字节数组使用Base64.getEncoder().encode();
  解密使用Base64.getDecoder().decode();
  对于URL安全或MIME的Base64，只需将上述getEncoder()getDecoder()更换为getUrlEncoder()getUrlDecoder()
  或getMimeEncoder()和getMimeDecoder()即可。

(6)RSA
RSA加密、解密、签名、验签的原理及方法: https://www.cnblogs.com/pcheng/p/9629621.html
1)　RSA加密是一种非对称加密。可以在不直接传递密钥的情况下，完成解密。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。是由一对密钥来进行加解密的过程，分别称为公钥和私钥。
2)RSA加密、签名区别
加密和签名都是为了安全性考虑，但略有不同。单的说，加密是为了防止信息被泄露，而签名是为了防止信息被篡改。



2 Demo
java 实现各种加密（MD5 ，SHA-1,SHA-256）: https://blog.csdn.net/qq_33113141/article/details/51858629?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control
Java数据加密(MD5,sha1,sha256)：https://blog.csdn.net/chain_fei/article/details/77822830
java各种加密方法实现:https://blog.csdn.net/Q563573095/article/details/79625836?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control

3 各种概念
(1)对称加密非对称加密
(2)公钥和私钥的概念
   在现代密码体制中加密和解密是采用不同的密钥（公开密钥），也就是公开密钥算法（也叫非对称算法、双钥算法）”，每个通信方均需要两个密钥，即公钥和私钥，这两把密钥可以互为加解密。
   公钥是公开的，不需要保密，而私钥是由个人自己持有，并且必须妥善保管和注意保密。
(3) 证书的概念
数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后，用CA的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机 构的公章）后形成的一个数字文件。
CA完成签发证书后，会将证书发布在CA的证书库（目录服务器）中，任何人都可以查询和下载，因此数字证书和公钥一样是公开的。实际上，数字证书就是经过CA认证过的公钥。
(4)

(5)Http报文
HTTP报文的结构: https://blog.csdn.net/kongmin_123/article/details/82154780?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control
HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。
1)什么是HTTP报文
HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。
2)HTTP报文由哪几部分构成？各部分都有什么作用？
HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。报文首部包括请求行和请求头部，报文主体主要包含应被发送的数据。通常，不一定有报文主体。
3)请求报文及响应报文的结构
请求报文结构：
一个HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。
请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。该部分位于数据首行，基本格式为：
GET /index.html HTTP/1.1
该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。
HTTP响应报文：
HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。

(6) 加密
Android签名机制:https://www.jianshu.com/p/fa0e2273f2a0
1)数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为"密文"，使其只能在输入相应的密钥之后才能显示出本来内容，
通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。
  加密一般分为对称加密和非对称加密。
  一般非对称加密更为安全，而一般非对称加密的操作是用公钥进行加密，接收端用私钥进行解密。
2)消息摘要
又称数字摘要或数字指纹。简单来说就是任意长度数据经过单向的HASH函数，生成一个固定长度的HASH值。也就是经过算法处理后的一个固定长度的数据。
3)数字签名
数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。
接收者只有用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，
在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。
和加密相比正好返过来，是用私钥加密，用公钥解密。
4)数字证书
数字证书就是互联网通讯中标志通讯各方身份信息的一串数字。简单来说就是能证明通信方的身份，能确定和我通信的是你，而不是某个假冒你的人。
假如你这边把应用用私钥签名，把签名后的文件和公钥都发给接收端。但是如果中间有人拦截，把文件换了，重新用自己的私钥签名，再换对应的公钥发给接收端。
接收端依旧能正常校验成功，难道这就说明这个文件是正确的吗？所以才需要数字证书来证明这个公钥来自于真正的发送端。

(7) 数字签名&数字证书
翻译】数字签名是什么？：https://www.jianshu.com/p/bef4de71d2c5
数字签名：
信息实体经HASH函数后得到一个摘要，摘要经过私钥加密后形成数字签名。
数字证书：
证书中心的信息+个人的信息+个人的公钥，经过证书中心的私钥加密后，得到数字证书。

4 相关需求
(1) 金融备案整改
问题1：交易过程报文是否采用了数字签名机制、是否用HASH、数字签名、MAC算法保证完整性?
客户端软件未使用HASH、数字签名、MAC算法保证完整性
分析：交易过程中的请求报文参数单独做加密，需要交易流程里页面的前端修改
App端，getFmSysParams ，前端入参+机器码+时间戳，生成sign签名和system参数网关层
问题2：在App的加密流程中，对称密钥、私钥如何存储？
报文内容+时间戳+设备标识+密钥转换为md5，且本地存储aes密钥在so库时，未采用分段存储
分析：

之前是一整个密钥存在so库，然后so加固，密钥要改成分段存储，MD5改成sha256,分段加密。
在交易里面找部分接口进行处理，这个方案不涉及网关和APP

5 实际中应用到的
Android 拿到私钥字符串对目标字符串进行加密: https://www.jianshu.com/p/51a8e9127c4c
(1)Android中的签名  apk和app的签名信息
Android签名机制:https://www.jianshu.com/p/fa0e2273f2a0
Android中签名、证书、公钥密钥的概念及使用:https://blog.csdn.net/u011974987/article/details/52415037?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control
1)是什么签名？
Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有，
Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。
没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。
2)为什么要有签名？
开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。
发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致。
3)命令读取签名信息： keytool -printcert -jarfile xxx.apk
代码获取：

(2)App 端如何安全存放静态密钥？
APP 需要和服务端进行交互，部分需要权限的接口就要用到密钥，这个时候密钥该怎么存放在客户端中？感觉怎么存放都是很不安全，一旦反编译客户端不是直接可以拿到密钥了么？
网上查了，得到以下解决方案
1，把密钥进行再次加密混淆存放，混淆加密方法达到反编译破解成本
2，把密钥和加密方法编译成动态库，动态库里一样混淆代码，然后动态库提供接口调用获取密钥或者加密
有没有更好的方法？

(3) 移动App该如何保存用户密码
(4) 关于Android密钥的存储
关于Android密钥的存储，大家都是怎么做的？: https://bbs.csdn.net/topics/392204231
最近项目中，老板想隐藏api接口。就是请求的时候数据用密钥加密后传给服务器，服务器再用相同的密钥进行解密。
现在的关键是这个密钥只能让服务器和本地app知道。不能被别人获取，请问存储在哪里好？
大家都知道java代码很容易被反编译。我在网上查资料，目前比较好的方案是用ndk加密存储密钥，再用java去掉c++。
我想了一种方法是把密钥存在服务器上，app通过https去服务器获取密钥，但是服务器会验证app的keystone，及包名等信息，如果正确就返回密钥。这样的话更改密钥在服务器端就行，
不用重新打包发版。请问这样做可以吗？

只要你的包还能被反编译的话，你说的两种方法都很好被破解。
1.用ndk加密存储密钥，他反编译你的代码后，native方法声明是不会混淆的，他可以用你的so文件调用你的获取密钥的方法。
2.用服务器验证，反编译也能拿到你的keystone，抓包也能拿到。你的keystone总得存在本地的吧？

我们公司解决方案是，
1加固apk，找一个市面用的比较多的加固方案，防止api反编译。
2.所有网络通信都放到ndk层，这样上层只需要调用native方法获取数据就好了，这个反编译破解难度比较大。
最后，既然有加密，那就有解密，没有完美的加密手段，只能尽可能防止啦，不要太纠结

(5) Android keystore
Android Keystore漫谈: https://www.jianshu.com/p/644ddb6e3d9c
1)Keystore
Keystore 传统理解为密钥库，或者钥匙串。一个keystore里面可以放多组秘钥，每组密钥都有有效期、地址、公司等信息，可以通过别名来进行区分拿取。
开发者将录入自己信息的秘钥（而非秘钥库Keystore）存入APP中，以认证此APP为自己开发。
Keystore可理解为一个容器，存放开发者信息、私钥、公钥的容器。
Keytool ：是一个有效的安全钥匙和证书的管理工具，Java 中的 keytool.exe （位于 JDK\Bin 目录下）可以用来创建数字证书；
keystore：数字证书，是一个存储了证书的文件。文件包含证书的私钥，公钥和对应的数字证书的信息。
2)为什么使用Keystore?
为什么使用Keystore？在回答这个问题前，我们先来看看Keystore是什么东西。我们都知道，古时丫鬟被买下时，主人要求丫鬟签写卖身契，表示这个丫鬟是老王头家的。Keystore就如同卖身契，
表示这个APP是某一名开发者开发的。有了Keystore，开发者在发布自己的应用到市场时，就无需担心自己的APP被他人抢走了，因此使用Keystore很有必要。
3) Keystore怎么证明APP开发者的身份呢？
在生成Keystore的时候，开发者会录入自己姓名、单位、组织、所在城市、省份、国家代码等信息以保证此Keystore是自己的，将录入自己信息的Keystore放入APP中，这样就可以保证这个APP是自己开发的了。

(6) Android中保存静态秘钥（加密秘钥，特殊id字段等）
Android中保存静态秘钥（加密秘钥，特殊id字段等）: https://blog.csdn.net/lplj717/article/details/52994331
Android安全开发之浅谈密钥硬编码: https://www.cnblogs.com/alisecurity/archive/2016/05/16/5498539.html
1)如何在App中保存静态秘钥以及保证其安全性。许多的移动app需要在app端保存一些静态字符串常量，其可能是静态秘钥、第三方appId等。在保存这些字符串常量的时候就涉及到了如何保证秘钥的安全性问题。如何保证在App中静态秘钥唯一且正确安全，这是一个很重要的问题
2)现今保存静态秘钥的几种主流通用做法
通过SharedPreferences保存静态秘钥；
通过Java硬编码的方式保存
通过NDK的方式，将静态秘钥保存在so文件中；
3)几种保存静态秘钥方式的优劣势：
密钥直接明文存在sharedprefs文件中，这是最不安全的。
密钥直接硬编码在Java代码中，这很不安全，dex文件很容易被逆向成java代码。
将密钥分成不同的几段，有的存储在文件中、有的存储在代码中，最后将他们拼接起来，可以将整个操作写的很复杂，这因为还是在java层，逆向者只要花点时间，也很容易被逆向。
用ndk开发，将密钥放在so文件，加密解密操作都在so文件里，这从一定程度上提高了的安全性，挡住了一些逆向者，但是有经验的逆向者还是会使用IDA破解的。
在so文件中不存储密钥，so文件中对密钥进行加解密操作，将密钥加密后的密钥命名为其他普通文件，存放在assets目录下或者其他目录下，接着在so文件里面添加无关代码（花指令），虽然可以增加静态分析难度，但是可以使用动态调式的方法，追踪加密解密函数，也可以查找到密钥内容。


