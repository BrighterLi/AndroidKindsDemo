1 设计模式分为三大类：
创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式
前面讲过，社会化的分工越来越细，自然在软件设计方面也是如此，因此对象的创建和对象的使用分开也就成
为了必然趋势。因为对象的创建会消耗掉系统的很多资源，所以单独对对象的创建进行研究，
从而能够高效地创建对象就是创建型模式要探讨的问题。

结构型模式，共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，
因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。
对象结构的设计很容易体现出设计人员水平的高低

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
其实还有两类：并发型模式和线程池模式。
在对象的结构和对象的创建问题都解决了之后，就剩下对象的行为问题了，如果对象的行为设计的好，
那么对象的行为就会更清晰，它们之间的协作效率就会提高


2 设计模式的六大原则
单一职责原则
里氏替换原则（Liskov Substitution Principle）
依赖倒转原则（Dependence Inversion Principle）
接口隔离原则（Interface Segregation Principle）
迪米特法则（最少知道原则）（Demeter Principle）
合成复用原则（Composite Reuse Principle）

3 创建型
4 结构型
5 行为型
(1) 观察者模式
设计模式（五）观察者模式: https://blog.csdn.net/itachi85/article/details/50773358
1)观察者模式（又被称为发布-订阅（Publish/Subscribe）模式
它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。
2)在观察者模式中有如下角色：
Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。
ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。
Observer：抽象观察者，是观察者者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。
ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。
3)使用场景
关联行为场景，需要注意的是，关联行为是可拆分的，而不是“组合”关系。
事件多级触发场景。
跨系统的消息交换场景，如消息队列、事件总线的处理机制。
4)优缺点
优点
解除耦合，让耦合的双方都依赖于抽象，从而使得各自的变换都不会影响另一边的变换。
缺点
在应用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、
多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，
那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。
5)Android中的观察者模式
android源码中也有很多使用了观察者模式，比如OnClickListener、ContentObserver、android.database.Observable等；还有组件通讯库RxJava、RxAndroid、EventBus；在这里将拿我们最常用的Adapter的notifyDataSetChanged()方法来举例： 
当我们用ListView的时候，数据发生变化的时候我们都会调用Adapter的notifyDataSetChanged()方法，这个方法定义在BaseAdaper中
