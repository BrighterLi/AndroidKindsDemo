1 Http报文
HTTP报文的结构: https://blog.csdn.net/kongmin_123/article/details/82154780?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.control
HTTP通信过程包括客户端往服务器端发送请求以及服务器端给客户端返回响应两个过程。在这两个过程中就会产生请求报文和响应报文。
1)什么是HTTP报文
HTTP报文是用于HTTP协议交互的信息，HTTP报文本身是由多行数据构成的字符串文本。客户端的HTTP报文叫做请求报文，服务器端的HTTP报文叫做响应报文。
2)HTTP报文由哪几部分构成？各部分都有什么作用？
HTTP报文由报文首部和报文主体构成，中间由一个空行分隔。 报文首部是客户端或服务器端需处理的请求或响应的内容及属性， 可以传递额外的重要信息。报文首部包括请求行和请求头部，报文主体主要包含应被发送的数据。通常，不一定有报文主体。
3)请求报文及响应报文的结构
请求报文结构：
一个HTTP请求报文由请求行（request line）、请求头部（request header）、空行和请求数据4个部分构成。
请求行数据格式由三个部分组成：请求方法、URI、HTTP协议版本，他们之间用空格分隔。该部分位于数据首行，基本格式为：
GET /index.html HTTP/1.1
该部分的请求方法字段给出了请求类型，URI给出请求的资源位置(/index.html)。HTTP中的请求类型包括:GET、POST、HEAD、PUT、DELETE。一般常用的为GET和POST方式。最后HTTP协议版本给出HTTP的版本号。
HTTP响应报文：
HTTP响应报文由状态行（HTTP版本、状态码（数字和原因短语））、响应头部、空行和响应体4个部分构成。

2 加密
Android签名机制:https://www.jianshu.com/p/fa0e2273f2a0
1)数据加密的基本过程就是对原来为明文的文件或数据按某种算法进行处理，使其成为不可读的一段代码，通常称为"密文"，使其只能在输入相应的密钥之后才能显示出本来内容，
通过这样的途径来达到保护数据不被非法人窃取、阅读的目的。
  加密一般分为对称加密和非对称加密。
  一般非对称加密更为安全，而一般非对称加密的操作是用公钥进行加密，接收端用私钥进行解密。
2)消息摘要
又称数字摘要或数字指纹。简单来说就是任意长度数据经过单向的HASH函数，生成一个固定长度的HASH值。也就是经过算法处理后的一个固定长度的数据。
3)数字签名
数字签名的作用就是保证信息传输的完整性、发送者的身份认证、防止交易中的抵赖发生。数字签名技术是将摘要信息用发送者的私钥加密，与原文一起传送给接收者。
接收者只有用发送者的公钥才能解密被加密的摘要信息然后用HASH函数对收到的原文产生一个摘要信息，与解密的摘要信息对比。如果相同，则说明收到的信息是完整的，
在传输过程中没有被修改，否则说明信息被修改过，因此数字签名能够验证信息的完整性。
和加密相比正好返过来，是用私钥加密，用公钥解密。
4)数字证书
数字证书就是互联网通讯中标志通讯各方身份信息的一串数字。简单来说就是能证明通信方的身份，能确定和我通信的是你，而不是某个假冒你的人。
假如你这边把应用用私钥签名，把签名后的文件和公钥都发给接收端。但是如果中间有人拦截，把文件换了，重新用自己的私钥签名，再换对应的公钥发给接收端。
接收端依旧能正常校验成功，难道这就说明这个文件是正确的吗？所以才需要数字证书来证明这个公钥来自于真正的发送端。

3 数字签名&数字证书
翻译】数字签名是什么？：https://www.jianshu.com/p/bef4de71d2c5
数字签名：
信息实体经HASH函数后得到一个摘要，摘要经过私钥加密后形成数字签名。
数字证书：
证书中心的信息+个人的信息+个人的公钥，经过证书中心的私钥加密后，得到数字证书。

4 相关需求
  (1) 金融备案整改
  问题1：交易过程报文是否采用了数字签名机制、是否用HASH、数字签名、MAC算法保证完整性?
  客户端软件未使用HASH、数字签名、MAC算法保证完整性
  分析：交易过程中的请求报文参数单独做加密，需要交易流程里页面的前端修改
  App端，getFmSysParams ，前端入参+机器码+时间戳，生成sign签名和system参数网关层
  问题2：在App的加密流程中，对称密钥、私钥如何存储？
  报文内容+时间戳+设备标识+密钥转换为md5，且本地存储aes密钥在so库时，未采用分段存储
  分析：

  之前是一整个密钥存在so库，然后so加固，密钥要改成分段存储，MD5改成sha256,分段加密。
  在交易里面找部分接口进行处理，这个方案不涉及网关和APP

 5 实际中应用到的
  Android 拿到私钥字符串对目标字符串进行加密: https://www.jianshu.com/p/51a8e9127c4c
  (1)Android中的签名  apk和app的签名信息
  Android签名机制:https://www.jianshu.com/p/fa0e2273f2a0
  Android中签名、证书、公钥密钥的概念及使用:https://blog.csdn.net/u011974987/article/details/52415037?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control
  1)是什么签名？
  Android要求所有已安装的应用程序都使用数字证书做数字签名，数字证书的私钥由应用开发者持有，
  Android使用证书作为标示应用程序作者的一种方式，并在应用程序之间建立信任的关系。 证书并不用来控制用户能否安装哪个应用。证书不需要由证书认证中心签名；完全可以使用自制签名证书。
  没有正确签名的应用，Android系统不会安装或运行。此规则适用于在任何地方运行的Android系统，不管是在模拟器还是真实设备上。因为这个原因。在真机或模拟器上运行或者调试应用前，必须为其设置好签名。
  2)为什么要有签名？
  开发Android的人这么多，完全有可能把类名，包名命名成同样的名字，这个时候该如何区分？所以，这时候就需要签名来区分了，由于开发商可能通过使用相同的Package Name来混淆替换已经安装的程序，签名可以保证相当名字，但是签名不同的包不被替换。
  发布过Android应用的朋友们应该都知道，Android APK的发布是需要签名的。签名机制在Android应用和框架中有着十分重要的作用。例如，Android系统禁止更新安装签名不一致的APK；如果应用需要使用system权限，必须保证APK签名与Framework签名一致。
  3)命令读取签名信息： keytool -printcert -jarfile xxx.apk
  代码获取：

  (2)App 端如何安全存放静态密钥？
  APP 需要和服务端进行交互，部分需要权限的接口就要用到密钥，这个时候密钥该怎么存放在客户端中？感觉怎么存放都是很不安全，一旦反编译客户端不是直接可以拿到密钥了么？
  网上查了，得到以下解决方案
  1，把密钥进行再次加密混淆存放，混淆加密方法达到反编译破解成本
  2，把密钥和加密方法编译成动态库，动态库里一样混淆代码，然后动态库提供接口调用获取密钥或者加密
  有没有更好的方法？

  (3) 移动App该如何保存用户密码
  (4) 关于Android密钥的存储
  关于Android密钥的存储，大家都是怎么做的？: https://bbs.csdn.net/topics/392204231
  最近项目中，老板想隐藏api接口。就是请求的时候数据用密钥加密后传给服务器，服务器再用相同的密钥进行解密。
  现在的关键是这个密钥只能让服务器和本地app知道。不能被别人获取，请问存储在哪里好？
  大家都知道java代码很容易被反编译。我在网上查资料，目前比较好的方案是用ndk加密存储密钥，再用java去掉c++。
  我想了一种方法是把密钥存在服务器上，app通过https去服务器获取密钥，但是服务器会验证app的keystone，及包名等信息，如果正确就返回密钥。这样的话更改密钥在服务器端就行，
  不用重新打包发版。请问这样做可以吗？

  只要你的包还能被反编译的话，你说的两种方法都很好被破解。
  1.用ndk加密存储密钥，他反编译你的代码后，native方法声明是不会混淆的，他可以用你的so文件调用你的获取密钥的方法。
  2.用服务器验证，反编译也能拿到你的keystone，抓包也能拿到。你的keystone总得存在本地的吧？

  我们公司解决方案是，
  1加固apk，找一个市面用的比较多的加固方案，防止api反编译。
  2.所有网络通信都放到ndk层，这样上层只需要调用native方法获取数据就好了，这个反编译破解难度比较大。
  最后，既然有加密，那就有解密，没有完美的加密手段，只能尽可能防止啦，不要太纠结

  (5) Android keystore
  Android Keystore漫谈: https://www.jianshu.com/p/644ddb6e3d9c
  1)Keystore
  Keystore 传统理解为密钥库，或者钥匙串。一个keystore里面可以放多组秘钥，每组密钥都有有效期、地址、公司等信息，可以通过别名来进行区分拿取。
  开发者将录入自己信息的秘钥（而非秘钥库Keystore）存入APP中，以认证此APP为自己开发。
  Keystore可理解为一个容器，存放开发者信息、私钥、公钥的容器。
  Keytool ：是一个有效的安全钥匙和证书的管理工具，Java 中的 keytool.exe （位于 JDK\Bin 目录下）可以用来创建数字证书；
  keystore：数字证书，是一个存储了证书的文件。文件包含证书的私钥，公钥和对应的数字证书的信息。
  2)为什么使用Keystore?
  为什么使用Keystore？在回答这个问题前，我们先来看看Keystore是什么东西。我们都知道，古时丫鬟被买下时，主人要求丫鬟签写卖身契，表示这个丫鬟是老王头家的。Keystore就如同卖身契，
  表示这个APP是某一名开发者开发的。有了Keystore，开发者在发布自己的应用到市场时，就无需担心自己的APP被他人抢走了，因此使用Keystore很有必要。
  3) Keystore怎么证明APP开发者的身份呢？
  在生成Keystore的时候，开发者会录入自己姓名、单位、组织、所在城市、省份、国家代码等信息以保证此Keystore是自己的，将录入自己信息的Keystore放入APP中，这样就可以保证这个APP是自己开发的了。

  (6) Android中保存静态秘钥（加密秘钥，特殊id字段等）
  Android中保存静态秘钥（加密秘钥，特殊id字段等）: https://blog.csdn.net/lplj717/article/details/52994331
  Android安全开发之浅谈密钥硬编码: https://www.cnblogs.com/alisecurity/archive/2016/05/16/5498539.html
  1)如何在App中保存静态秘钥以及保证其安全性。许多的移动app需要在app端保存一些静态字符串常量，其可能是静态秘钥、第三方appId等。在保存这些字符串常量的时候就涉及到了如何保证秘钥的安全性问题。如何保证在App中静态秘钥唯一且正确安全，这是一个很重要的问题
  2)现今保存静态秘钥的几种主流通用做法
  通过SharedPreferences保存静态秘钥；
  通过Java硬编码的方式保存
  通过NDK的方式，将静态秘钥保存在so文件中；
  3)几种保存静态秘钥方式的优劣势：
  密钥直接明文存在sharedprefs文件中，这是最不安全的。
  密钥直接硬编码在Java代码中，这很不安全，dex文件很容易被逆向成java代码。
  将密钥分成不同的几段，有的存储在文件中、有的存储在代码中，最后将他们拼接起来，可以将整个操作写的很复杂，这因为还是在java层，逆向者只要花点时间，也很容易被逆向。
  用ndk开发，将密钥放在so文件，加密解密操作都在so文件里，这从一定程度上提高了的安全性，挡住了一些逆向者，但是有经验的逆向者还是会使用IDA破解的。
  在so文件中不存储密钥，so文件中对密钥进行加解密操作，将密钥加密后的密钥命名为其他普通文件，存放在assets目录下或者其他目录下，接着在so文件里面添加无关代码（花指令），虽然可以增加静态分析难度，但是可以使用动态调式的方法，追踪加密解密函数，也可以查找到密钥内容。

 6证书CA
 http://blog.sina.com.cn/s/blog_5fa211b40102wuah.html
 (1)TLS/SSL证书链
 保证通信安全至少要使用 HTTPS 协议，也就是说使用安全传输层协议（TLS）或是它的前身安全套接层协议（SSL）加密的通信。
 (2).证书检查
 1）Certificate Pinning
 其实Certificate Pinning是OkHttp 实现的一个类似于HPKP的技术，目的是为了使客户
 端可以有主动的信任CA的权利，它的工作原理就是使用预先设置的证书指纹和服务器传过
 来的证书链中的证书指纹进行匹配，只要有任何一对指纹匹配成功，则认为是一次合法的连
 接，否则禁止本次链接。
 2）预埋证书
 把数字证书以文件或者字符串的形式写在本地，在SSL握手的时候用本地预埋的证书和服务器传过来的证书进行匹配，如果匹配不成功则禁止本次通信。
 3）Certificate Pinning和预埋证书做法的比较（以OkHttp为例）

