
代理模式的应用场景： 
如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法： 
1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。 
2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。 
使用代理模式，可以将功能划分的更加清晰，有助于后期维护！

静态代理的缺点
虽然静态代理实现简单，且不侵入原代码，但是，当场景稍微复杂一些的时候，静态代理的缺点也会暴露出来。
1、 当需要代理多个类的时候，由于代理对象要实现与目标对象一致的接口，有两种方式：
只维护一个代理类，由这个代理类实现多个接口，但是这样就导致代理类过于庞大
新建多个代理类，每个目标对象对应一个代理类，但是这样会产生过多的代理类
2、 当接口需要增加、删除、修改方法的时候，目标对象与代理类都要同时修改，不易维护。
如何改进？
当然是让代理类动态的生成啦，也就是动态代理。

动态代理
java动态代理实现与原理详细分析：https://www.cnblogs.com/gonjan-blog/p/6685611.html
    动态代理的过程，代理对象和被代理对象的关系不像静态代理那样一目了然，清晰明了。因为动态代理的过程中，
我们并没有实际看到代理类，也没有很清晰地的看到代理类的具体样子，而且动态代理中被代理对象和代理对象
是通过InvocationHandler来完成的代理过程的，其中具体是怎样操作的，为什么代理对象执行的方法都会通过
InvocationHandler中的invoke方法来执行。
    我们可以对InvocationHandler看做一个中介类，中介类持有一个被代理对象，在invoke方法中调用了被代理对象的相应方法。
通过聚合方式持有被代理对象的引用，把外部对invoke的调用最终都转为对被代理对象的调用。



ms:
描述动态代理的几种实现方式？分别说出相应的优缺点
代理可以分为 "静态代理" 和 "动态代理"，动态代理又分为 "JDK动态代理" 和 "CGLIB动态代理" 实现。
静态代理：代理对象和实际对象都继承了同一个接口，在代理对象中指向的是实际对象的实例，这样对外暴露的是代理对象而真正调用的是 Real Object
优点：可以很好的保护实际对象的业务逻辑对外暴露，从而提高安全性。
缺点：不同的接口要有不同的代理类实现，会很冗余
JDK 动态代理：
为了解决静态代理中，生成大量的代理类造成的冗余；
JDK 动态代理只需要实现 InvocationHandler 接口，重写 invoke 方法便可以完成代理的实现，
jdk的代理是利用反射生成代理类 Proxyxx.class 代理类字节码，并生成对象
jdk动态代理之所以只能代理接口是因为代理类本身已经extends了Proxy，而java是不允许多重继承的，但是允许实现多个接口
优点：解决了静态代理中冗余的代理实现类问题。
缺点：JDK 动态代理是基于接口设计实现的，如果没有接口，会抛异常。
CGLIB 代理：
由于 JDK 动态代理限制了只能基于接口设计，而对于没有接口的情况，JDK方式解决不了；
CGLib 采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑，来完成动态代理的实现。
实现方式实现 MethodInterceptor 接口，重写 intercept 方法，通过 Enhancer 类的回调方法来实现。
但是CGLib在创建代理对象时所花费的时间却比JDK多得多，所以对于单例的对象，因为无需频繁创建对象，用CGLib合适，反之，使用JDK方式要更为合适一些。
同时，由于CGLib由于是采用动态创建子类的方法，对于final方法，无法进行代理。
优点：没有接口也能实现动态代理，而且采用字节码增强技术，性能也不错。
缺点：技术实现相对难理解些。
